
===== src/games/solitaire/Solitaire.ui.tsx =====

import { useEffect, useMemo, useRef, useState } from 'react';
import { Card as MUICard, CardContent, Stack, Typography, Chip, Button, Box, Divider, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import { motion, AnimatePresence } from 'framer-motion';
import { useCasino } from '@games/core/useCasino';
import { FlyCoins } from '@shared/fx/FlyCoins';
import { Confetti } from '@shared/fx/Confetti';

import {
  SUITS, RANKS, Card as K, State, deal, canOnTableau, canOnFound, isValidStack, deep,
  trySolve, generateDealForDifficulty, isRed,
} from './Solitaire.logic';

import { applySolitaireRewards } from './Solitaire.rewards';

type Difficulty = 'easy'|'medium'|'hard'|'extreme';

export default function Solitaire() {
  const GAME_KEY = 'hilo-solitaire' as const; // unikĂˇtnĂ­ klĂ­ÄŤ do cenĂ­ku / historie
  const { balance, priceTable, defaultPayout, startRound, finishRound } = useCasino();

  const [price, setPrice] = useState(() => priceTable?.hilo?.entry ?? 6);
  const [payoutWin, setPayoutWin] = useState(() => priceTable?.hilo?.win ?? 18);

  const [phase, setPhase] = useState<'idle'|'playing'|'auto'|'won'|'lost'>('idle');
  const [drawMode, setDrawMode] = useState<1|3>(1);
  const [difficulty, setDifficulty] = useState<Difficulty>('easy');

  const [state, setState] = useState<State>(() => deal(drawMode));
  const [selected, setSelected] = useState<{ from: 'waste' } | { from: 'tableau'; col: number; index: number } | null>(null);
  const [steps, setSteps] = useState(0);
  const [msg, setMsg] = useState('Zvol obtĂ­Ĺľnost a klikni na NovĂˇ hra.');

  const undoRef = useRef<State[]>([]);
  const roundRef = useRef<string | null>(null);

  // efekty po vĂ˝hĹ™e
  const [overlay, setOverlay] = useState<{ open: boolean; payout: number }>({ open: false, payout: 0 });
  const [coinsFx, setCoinsFx] = useState(false);
  const [confettiFx, setConfettiFx] = useState(false);

  useEffect(() => {
    const pt = priceTable?.hilo;
    if (pt?.entry != null) setPrice(pt.entry|0);
    if (pt?.win != null) setPayoutWin(pt.win|0);
  }, [priceTable]);

  // detekce vĂ˝hry
  useEffect(() => {
    const won = SUITS.every((s) => state.found[s].length === 13);
    if ((phase === 'playing' || phase === 'auto') && won) {
      setPhase('won');
      setMsg('VyhrĂˇl jsi! đźŹ†');
      const payout = defaultPayout(GAME_KEY as any, 'win') ?? payoutWin;
      finishRound(GAME_KEY as any, { roundId: roundRef.current!, result: 'win', payout, details: { drawMode, difficulty, steps } });
      roundRef.current = null;

      // đź”ą META ODMÄšNY
      applySolitaireRewards('win', { moves: steps });

      // efekty + overlay + mince do banku
      setOverlay({ open: true, payout });
      setCoinsFx(true); setConfettiFx(true);
      setTimeout(() => { setCoinsFx(false); setConfettiFx(false); }, 1200);
    }
  }, [state, phase, drawMode, difficulty, steps, payoutWin, defaultPayout, finishRound]);

  const pushUndo = () => {
    undoRef.current.push(deep(state));
    if (undoRef.current.length > 200) undoRef.current.shift();
  };
  const undo = () => {
    if (!undoRef.current.length) return;
    const last = undoRef.current.pop()!;
    setState(last);
    setSelected(null);
    setPhase('playing');
    setMsg('Krok zpÄ›t.');
  };

  const startGame = () => {
    if (phase === 'playing' || phase === 'auto') return;
    const st = startRound(GAME_KEY as any, { drawMode, difficulty });
    if (!st?.ok) { setMsg('NemĂˇĹˇ dost mincĂ­ pro start.'); return; }
    roundRef.current = st.roundId;

    setMsg(`MĂ­chĂˇm balĂ­ÄŤek (${difficulty})â€¦`);
    const picked = generateDealForDifficulty(drawMode, difficulty);
    if (!picked) {
      const d = deal(drawMode);
      setState(d);
      setMsg('RozdĂˇno (fallback).');
    } else {
      setState(picked.deal);
      setMsg(
        difficulty === 'easy' ? 'RozdĂˇno â€“ hodnÄ› hratelnĂ˝ layout đź‘Ť'
        : difficulty === 'medium' ? 'RozdĂˇno â€“ spĂ­Ĺˇ pĹ™Ă­vÄ›tivĂ©.'
        : difficulty === 'hard' ? 'RozdĂˇno â€“ nĂˇroÄŤnÄ›jĹˇĂ­ kolo.'
        : 'RozdĂˇno â€“ extrĂ©mnÄ› utaĹľenĂ©. Bez chyby!'
      );
    }
    undoRef.current = [];
    setSelected(null);
    setSteps(0);
    setPhase('playing');
  };

  const giveUp = () => {
    if (phase !== 'playing' && phase !== 'auto') return;
    setPhase('lost');
    setMsg('VzdĂˇno.');
    const payout = defaultPayout(GAME_KEY as any, 'loss') ?? 0;
    finishRound(GAME_KEY as any, { roundId: roundRef.current!, result: 'loss', payout, details: { drawMode, difficulty } });
    roundRef.current = null;

    // đź”ą META ODMÄšNY (prohra)
    applySolitaireRewards('loss');
  };

  const autoFlip = (st: State) => {
    const cols = st.tableau.map((col) => {
      if (!col.length) return col;
      const top = col[col.length - 1];
      return top.faceUp ? col : [...col.slice(0, -1), { ...top, faceUp: true }];
    });
    return { ...st, tableau: cols };
  };

  // === Akce ===
  const drawFromStock = () => {
    if (phase !== 'playing') return;
    pushUndo();
    const st = deep(state);
    if (st.stock.length === 0) {
      if (!st.waste.length) { undoRef.current.pop(); return; }
      st.stock = st.waste.slice().reverse().map((c) => ({ ...c, faceUp: false }));
      st.waste = [];
      setState(st); setSelected(null); setMsg('Recyklace balĂ­ÄŤku.');
      return;
    }
    const n = Math.min(st.drawMode, st.stock.length);
    const take = st.stock.slice(-n).map((c) => ({ ...c, faceUp: true }));
    st.stock = st.stock.slice(0, st.stock.length - n);
    st.waste = st.waste.concat(take);
    setState(st); setSelected(null);
  };

  const tryAutoMoveToFoundation = (from: { kind: 'waste' } | { kind: 'tableau'; col: number }) => {
    if (phase !== 'playing') return false;
    const st = deep(state);

    if (from.kind === 'waste') {
      const card = st.waste[st.waste.length - 1]; if (!card) return false;
      const pile = st.found[card.suit];
      if (!canOnFound(card, pile)) return false;
      pushUndo();
      st.waste.pop(); pile.push(card);
      setState(autoFlip(st)); setSelected(null); return true;
    }
    if (from.kind === 'tableau') {
      const col = st.tableau[from.col];
      if (!col?.length) return false;
      const top = col[col.length - 1]; if (!top?.faceUp) return false;
      const pile = st.found[top.suit];
      if (!canOnFound(top, pile)) return false;
      pushUndo();
      col.pop(); pile.push(top);
      setState(autoFlip(st)); setSelected(null); return true;
    }
    return false;
  };

  const moveWasteToTableau = (toCol: number) => {
    const st = deep(state);
    const top = st.waste[st.waste.length - 1]; if (!top) return;
    const target = st.tableau[toCol][st.tableau[toCol].length - 1] || null;
    if (!canOnTableau(top, target)) return;
    pushUndo();
    st.waste.pop();
    st.tableau[toCol] = [...st.tableau[toCol], top];
    setState(autoFlip(st)); setSelected(null);
  };

  const moveTableauToTableau = (toCol: number, fromCol: number, fromIndex: number) => {
    const st = deep(state);
    const src = st.tableau[fromCol];
    const stack = src.slice(fromIndex);
    if (!stack.length || !isValidStack(stack)) return;
    const target = st.tableau[toCol][st.tableau[toCol].length - 1] || null;
    if (!canOnTableau(stack[0], target)) return;
    if (!st.tableau[toCol].length && stack[0].rank !== 'K') return;
    pushUndo();
    st.tableau[fromCol] = st.tableau[fromCol].slice(0, fromIndex);
    st.tableau[toCol] = [...st.tableau[toCol], ...stack];
    setState(autoFlip(st)); setSelected(null);
  };

  const moveToFoundation = (suit: K['suit'], payload: { src: 'waste' } | { src: 'tableau'; col: number; index: number }) => {
    const st = deep(state);
    const pile = st.found[suit];
    if (payload.src === 'waste') {
      const card = st.waste[st.waste.length - 1];
      if (!card || !canOnFound(card, pile)) return;
      pushUndo();
      st.waste.pop(); pile.push(card);
      setState(autoFlip(st)); setSelected(null); return;
    }
    const topIndex = st.tableau[payload.col].length - 1;
    if (payload.index !== topIndex) return;
    const card = st.tableau[payload.col][topIndex];
    if (!canOnFound(card, pile)) return;
    pushUndo();
    st.tableau[payload.col] = st.tableau[payload.col].slice(0, topIndex);
    pile.push(card);
    setState(autoFlip(st)); setSelected(null);
  };

  // === Klik logika + double-click auto-move
  const clickStock = () => drawFromStock();
  const clickWaste = () => {
    if (phase !== 'playing' || !state.waste.length) return;
    if (selected?.from === 'waste') {
      if (!tryAutoMoveToFoundation({ kind: 'waste' })) setSelected(null);
      return;
    }
    setSelected({ from: 'waste' });
  };
  const clickTableau = (colIdx: number, index: number) => {
    if (phase !== 'playing') return;
    const card = state.tableau[colIdx][index];
    if (!card.faceUp) {
      if (index === state.tableau[colIdx].length - 1) {
        pushUndo();
        const st = deep(state);
        st.tableau[colIdx][index] = { ...card, faceUp: true };
        setState(st);
      }
      return;
    }
    if (selected?.from === 'tableau' && selected.col === colIdx && selected.index === index && index === state.tableau[colIdx].length - 1) {
      if (!tryAutoMoveToFoundation({ kind: 'tableau', col: colIdx })) setSelected(null);
      return;
    }
    if (!selected) { setSelected({ from: 'tableau', col: colIdx, index }); return; }

    const target = state.tableau[colIdx][state.tableau[colIdx].length - 1] || null;

    if (selected.from === 'waste') {
      const top = state.waste[state.waste.length - 1]; if (!top) return;
      if (!canOnTableau(top, target)) { setMsg('Sem to nejde.'); return; }
      moveWasteToTableau(colIdx); return;
    }
    if (selected.from === 'tableau') {
      const { col, index: srcIndex } = selected;
      const stack = state.tableau[col].slice(srcIndex);
      if (!isValidStack(stack) || !canOnTableau(stack[0], target)) { setMsg('Sem to nejde.'); return; }
      if (!state.tableau[colIdx].length && stack[0].rank !== 'K') { setMsg('PrĂˇzdnĂ˝ sloupec â€“ jen s krĂˇlem.'); return; }
      moveTableauToTableau(colIdx, col, srcIndex); return;
    }
  };
  const clickEmptyCol = (colIdx: number) => {
    if (!selected) return;
    if (selected.from === 'waste') {
      const top = state.waste[state.waste.length - 1];
      if (!top || top.rank !== 'K') return;
      pushUndo();
      const st = deep(state);
      st.waste = st.waste.slice(0, -1);
      st.tableau[colIdx] = [...st.tableau[colIdx], top];
      setState(st); setSelected(null); return;
    }
    if (selected.from === 'tableau') {
      const { col, index } = selected;
      const stack = state.tableau[col].slice(index);
      if (!isValidStack(stack) || stack[0].rank !== 'K') return;
      moveTableauToTableau(colIdx, col, index); return;
    }
  };

  // === Auto-win tlaÄŤĂ­tko
  const autoWin = () => {
    if (phase !== 'playing') return;
    const current = deep(state);
    const solved = trySolve(current);
    if (!solved.ok) { setMsg('Solver to teÄŹ nedĂˇ. Zkus pĂˇr tahĹŻ a znovu Auto-win.'); return; }
    setMsg('Auto-win âś¨'); setPhase('auto'); setSelected(null);

    let st = deep(current);
    const path = solved.path.slice();
    const apply = (mv: any) => {
      switch (mv.type) {
        case 'flip': {
          const col = st.tableau[mv.col];
          if (col.length && !col[col.length - 1].faceUp) col[col.length - 1].faceUp = true;
          break;
        }
        case 'waste_to_found': {
          const card = st.waste.pop();
          if (card) st.found[card.suit].push(card);
          break;
        }
        case 'tab_to_found': {
          const top = st.tableau[mv.from].pop();
          if (top) st.found[top.suit].push(top);
          const col = st.tableau[mv.from];
          if (col.length && !col[col.length - 1].faceUp) col[col.length - 1].faceUp = true;
          break;
        }
        case 'tab_to_tab': {
          const stack = st.tableau[mv.from].slice(mv.index);
          st.tableau[mv.from] = st.tableau[mv.from].slice(0, mv.index);
          st.tableau[mv.to] = st.tableau[mv.to].concat(stack);
          const col = st.tableau[mv.from];
          if (col.length && !col[col.length - 1].faceUp) col[col.length - 1].faceUp = true;
          break;
        }
        case 'waste_to_tab':
        case 'waste_to_tab_empty': {
          const card = st.waste.pop();
          if (card) st.tableau[mv.to].push(card);
          break;
        }
        case 'recycle': {
          st.stock = st.waste.slice().reverse().map((c) => ({ ...c, faceUp: false }));
          st.waste = [];
          break;
        }
        case 'draw': {
          const n = Math.min(st.drawMode, st.stock.length);
          const take = st.stock.slice(-n).map((c) => ({ ...c, faceUp: true }));
          st.stock = st.stock.slice(0, st.stock.length - n);
          st.waste = st.waste.concat(take);
          break;
        }
      }
    };

    const tick = () => {
      if (!path.length) {
        setState(st);
        setPhase('playing'); // nechĂˇme useEffect detekovat WIN
        return;
      }
      for (let i = 0; i < 3 && path.length; i++) apply(path.shift());
      setState(deep(st));
      setTimeout(tick, 90);
    };
    tick();
  };

  // ===== Render =====
  const offDown = 18, offUp = 28;
  const canStart = phase !== 'playing' && phase !== 'auto' && balance >= (price | 0);

  const CardFace = ({ c, sel, onDoubleClick }: { c: K; sel?: boolean; onDoubleClick?: () => void }) => (
    <div className={`sol-card faceUp ${isRed(c.suit) ? 'red' : ''} ${sel ? 'sel' : ''}`} onDoubleClick={onDoubleClick}>
      <div className="rank">{c.rank}<br/>{c.suit}</div>
      <div className="pip">{c.rank}{c.suit}</div>
      <div className="rank br">{c.rank}<br/>{c.suit}</div>
    </div>
  );
  const CardDown = () => <div className="sol-card faceDown" />;

  return (
    <MUICard variant="outlined" sx={{ overflow: 'visible' }}>
      <CardContent>
        <Stack spacing={2}>
          {/* Top bar */}
          <Stack direction="row" alignItems="center" justifyContent="space-between" flexWrap="wrap" gap={1}>
            <Stack direction="row" gap={1} alignItems="center" flexWrap="wrap">
              <Chip label={`đź’° ${balance}`} />
              <Chip variant="outlined" label={`Vstup: -${price} â€˘ VĂ˝hra: +${payoutWin}`} />
              <Chip variant="outlined" label={`Kroky: ${steps}`} />
              <Chip variant="outlined" label={`Draw: ${drawMode} â€˘ ReĹľim: ${difficulty}`} />
            </Stack>
          </Stack>

          <Stack direction="row" gap={1} flexWrap="wrap">
            <select className="mg-select" value={difficulty} onChange={(e) => setDifficulty(e.target.value as Difficulty)} disabled={phase==='playing'||phase==='auto'}>
              <option value="easy">LehkĂˇ</option>
              <option value="medium">StĹ™ednĂ­</option>
              <option value="hard">TÄ›ĹľkĂˇ</option>
              <option value="extreme">ExtrĂ©mnĂ­</option>
            </select>
            <Button variant="contained" disabled={!canStart} onClick={startGame}>NovĂˇ hra</Button>
            <Button variant="outlined" disabled={undoRef.current.length===0 || phase==='idle'} onClick={undo}>Undo</Button>
            <Button variant="outlined" disabled={phase==='playing' || phase==='auto'} onClick={() => setDrawMode(d => d===1?3:1)}>
              PĹ™epnout {drawMode===1 ? 'na 3-card' : 'na 1-card'}
            </Button>
            <Button variant="outlined" disabled={phase!=='playing'} onClick={autoWin}>Auto-win</Button>
            <Button variant="outlined" disabled={phase!=='playing' && phase!=='auto'} onClick={giveUp}>VzdĂˇt</Button>
          </Stack>

          <Divider />

          {/* BOARD */}
          <div className="sol-board">
            <div className="sol-row">
              <div className="sol-side">
                {/* STOCK */}
                <div className="sol-pile" onClick={clickStock} title="Stock (klik = dobĂ­rat / recyklovat)">
                  {state.stock.length ? <CardDown/> : <div className="sol-mini" style={{ padding: 6 }}>PrĂˇzdnĂ˝ (klik = recyklace)</div>}
                </div>

                {/* WASTE fan */}
                <div className="sol-wasteFan">
                  {state.waste.slice(-3).map((c, i, arr) => {
                    const isTop = i === arr.length - 1;
                    const sel = selected?.from === 'waste';
                    return (
                      <div key={c.id} className="slot" style={{ left: i*10 }} onClick={clickWaste}>
                        <CardFace c={c} sel={sel && isTop} onDoubleClick={() => tryAutoMoveToFoundation({ kind: 'waste' })} />
                      </div>
                    );
                  })}
                  {state.waste.length===0 && (
                    <div className="sol-mini" style={{ position:'absolute', top:'40%', left:0, right:0, textAlign:'center' }}>Waste</div>
                  )}
                </div>
              </div>

              {/* FOUNDATIONS */}
              <div className="sol-found">
                {SUITS.map((s) => {
                  const pile = state.found[s];
                  const top = pile[pile.length - 1] || null;
                  return (
                    <div key={s} className="sol-pile" title={`Foundation ${s}`}
                      onClick={() => {
                        if (!selected) return;
                        if (selected.from === 'waste') return moveToFoundation(s, { src:'waste' });
                        if (selected.from === 'tableau') return moveToFoundation(s, { src:'tableau', col:selected.col, index:selected.index });
                      }}>
                      {top ? <CardFace c={top}/> : <div className="sol-mini" style={{ padding: 6 }}>{s}</div>}
                    </div>
                  );
                })}
              </div>
            </div>

            {/* TABLEAU */}
            <div className="sol-tableau">
              {state.tableau.map((col, ci) => {
                const offDown = 18, offUp = 28;
                const height = col.reduce((h, c) => h + (c.faceUp ? offUp : offDown), 0) + 6 + 116;
                return (
                  <div key={ci} className="sol-col" style={{ minHeight: Math.max(height, 190) }}
                    onClick={() => { if (!col.length) clickEmptyCol(ci); }}>
                    <div className="sol-fan" style={{ height }}>
                      {col.map((c, idx) => {
                        const y = col.slice(0, idx).reduce((p, cc) => p + (cc.faceUp ? offUp : offDown), 0);
                        const sel = selected?.from === 'tableau' && selected.col === ci && selected.index === idx;
                        const isTop = idx === col.length - 1;
                        return (
                          <div key={c.id} className="slot" style={{ top: y }} onClick={() => clickTableau(ci, idx)}>
                            {c.faceUp ? (
                              <CardFace c={c} sel={sel} onDoubleClick={() => { if (isTop) tryAutoMoveToFoundation({ kind: 'tableau', col: ci }); }} />
                            ) : (<CardDown />)}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* status */}
          {msg && (
            <div className="sol-msg">
              <span className={phase==='won' ? 'mg-badge mg-badge--win' : phase==='lost' ? 'mg-badge mg-badge--lose' : 'mg-badge mg-badge--draw'}>
                {msg}
              </span>
            </div>
          )}
        </Stack>
      </CardContent>

      {/* Efekty */}
      <Confetti show={confettiFx} />
      <FlyCoins show={coinsFx} toSelector="#bank-anchor" gain={overlay.payout} />

      {/* Overlay po vĂ˝hĹ™e */}
      <AnimatePresence>
        {overlay.open && (
          <motion.div
            initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
            style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,.35)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1500 }}
            onClick={() => setOverlay({ ...overlay, open: false })}
          >
            <motion.div
              onClick={(e) => e.stopPropagation()}
              initial={{ scale: .96, y: 8, opacity: 0 }}
              animate={{ scale: 1, y: 0, opacity: 1 }}
              exit={{ scale: .96, y: 8, opacity: 0 }}
              style={{ background: 'white', borderRadius: 16, padding: 24, minWidth: 280, boxShadow: '0 28px 60px rgba(0,0,0,.35)' }}
            >
              <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 1 }}>
                <Typography variant="h6" fontWeight={900}>VĂ˝hra!</Typography>
                <IconButton size="small" onClick={() => setOverlay({ ...overlay, open: false })}><CloseIcon /></IconButton>
              </Stack>
              <Typography variant="h5" fontWeight={900} color="success.main" align="center">+{overlay.payout}</Typography>
              <Typography variant="body2" align="center" sx={{ mt: 1 }}>Mince pĹ™ipsĂˇny na ĂşÄŤet. đź’°</Typography>
              <Stack direction="row" justifyContent="center" sx={{ mt: 2 }}>
                <Button variant="contained" onClick={() => setOverlay({ ...overlay, open: false })}>PokraÄŤovat</Button>
              </Stack>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </MUICard>
  );
}

===== src/games/solitaire/Solitaire.logic.ts =====

export type Suit = 'â™ ' | 'â™Ą' | 'â™¦' | 'â™Ł';
export type Rank = 'A'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'10'|'J'|'Q'|'K';

export type Card = {
  id: string;
  suit: Suit;
  rank: Rank;
  faceUp: boolean;
};

export type State = {
  tableau: Card[][];
  stock: Card[];
  waste: Card[];
  found: Record<Suit, Card[]>;
  drawMode: 1 | 3;
};

export type Move =
  | { type: 'flip'; col: number }
  | { type: 'waste_to_found'; suit: Suit }
  | { type: 'tab_to_found'; from: number; suit: Suit }
  | { type: 'tab_to_tab'; from: number; index: number; to: number }
  | { type: 'waste_to_tab'; to: number }
  | { type: 'waste_to_tab_empty'; to: number }
  | { type: 'recycle' }
  | { type: 'draw'; n: number };

export const SUITS: Suit[] = ['â™ ', 'â™Ą', 'â™¦', 'â™Ł'];
export const RANKS: Rank[] = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

export const isRed = (s: Suit) => s === 'â™Ą' || s === 'â™¦';
export const vRank = (r: Rank) =>
  r === 'A' ? 1 : r === 'J' ? 11 : r === 'Q' ? 12 : r === 'K' ? 13 : parseInt(r, 10);

export const deep = <T,>(x: T): T => JSON.parse(JSON.stringify(x));

export function makeDeck(): Card[] {
  const d: Card[] = [];
  for (const s of SUITS) for (const r of RANKS) {
    d.push({ id: `${r}${s}-${Math.random().toString(36).slice(2, 8)}`, suit: s, rank: r, faceUp: false });
  }
  for (let i = d.length - 1; i > 0; i--) {
    const j = (Math.random() * (i + 1)) | 0;
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}

export function canOnTableau(movingTop: Card | null, targetTop: Card | null): boolean {
  if (!movingTop) return false;
  if (!targetTop) return movingTop.rank === 'K';
  return isRed(movingTop.suit) !== isRed(targetTop.suit) && vRank(movingTop.rank) === vRank(targetTop.rank) - 1;
}

export function canOnFound(card: Card | null, pile: Card[]): boolean {
  if (!card) return false;
  if (!pile.length) return card.rank === 'A';
  const top = pile[pile.length - 1];
  return card.suit === top.suit && vRank(card.rank) === vRank(top.rank) + 1;
}

export function isValidStack(arr: Card[]): boolean {
  if (!arr.length || !arr[0].faceUp) return false;
  for (let i = 0; i < arr.length - 1; i++) {
    const a = arr[i], b = arr[i + 1];
    if (!b.faceUp) return false;
    if (isRed(a.suit) === isRed(b.suit)) return false;
    if (vRank(a.rank) !== vRank(b.rank) + 1) return false;
  }
  return true;
}

export function deal(drawMode: 1 | 3 = 1): State {
  const deck = makeDeck();
  const tableau: Card[][] = Array.from({ length: 7 }, () => []);
  let idx = 0;
  for (let c = 0; c < 7; c++) {
    for (let r = 0; r <= c; r++) {
      const card = deck[idx++];
      card.faceUp = r === c;
      tableau[c].push(card);
    }
  }
  return {
    tableau,
    stock: deck.slice(idx),
    waste: [],
    found: { 'â™ ': [], 'â™Ą': [], 'â™¦': [], 'â™Ł': [] },
    drawMode,
  };
}

/** Greedy solver â€“ pro Auto-win / Extreme enforcement */
export function trySolve(initial: State) {
  const MAX_ITERS = 1200;
  const seen = new Set<string>();
  const path: Move[] = [];

  const key = (st: State) =>
    JSON.stringify({
      t: st.tableau.map((c) => c.map((k) => [k.rank, k.suit, k.faceUp])),
      w: st.waste.map((k) => [k.rank, k.suit]),
      s: st.stock.length,
      f: SUITS.map((s) => st.found[s].length),
      d: st.drawMode,
    });

  const flipIfPossible = (st: State, colIdx: number) => {
    const col = st.tableau[colIdx];
    if (col.length && !col[col.length - 1].faceUp) {
      col[col.length - 1].faceUp = true;
      path.push({ type: 'flip', col: colIdx });
      return true;
    }
    return false;
  };

  const moveToFoundation = (st: State) => {
    const topW = st.waste[st.waste.length - 1];
    if (topW) {
      const dest = st.found[topW.suit];
      if (canOnFound(topW, dest)) {
        st.waste.pop();
        dest.push(topW);
        path.push({ type: 'waste_to_found', suit: topW.suit });
        return true;
      }
    }
    for (let c = 0; c < 7; c++) {
      const col = st.tableau[c];
      if (!col.length) continue;
      const top = col[col.length - 1];
      if (!top.faceUp) continue;
      const dest = st.found[top.suit];
      if (canOnFound(top, dest)) {
        col.pop();
        dest.push(top);
        path.push({ type: 'tab_to_found', from: c, suit: top.suit });
        flipIfPossible(st, c);
        return true;
      }
    }
    return false;
  };

  const moveToTableau = (st: State) => {
    for (let c = 0; c < 7; c++) {
      const col = st.tableau[c];
      for (let i = 0; i < col.length; i++) {
        const card = col[i];
        if (!card.faceUp) continue;
        const stack = col.slice(i);
        if (!isValidStack(stack)) continue;
        for (let d = 0; d < 7; d++) {
          if (d === c) continue;
          const tgtTop = st.tableau[d][st.tableau[d].length - 1] || null;
          if (canOnTableau(stack[0], tgtTop)) {
            if (!st.tableau[d].length && stack[0].rank !== 'K') continue;
            st.tableau[d] = st.tableau[d].concat(stack);
            st.tableau[c] = st.tableau[c].slice(0, i);
            path.push({ type: 'tab_to_tab', from: c, index: i, to: d });
            flipIfPossible(st, c);
            return true;
          }
        }
      }
    }
    const topW = st.waste[st.waste.length - 1];
    if (topW) {
      for (let d = 0; d < 7; d++) {
        const tgtTop = st.tableau[d][st.tableau[d].length - 1] || null;
        if (canOnTableau(topW, tgtTop)) {
          st.tableau[d].push(topW);
          st.waste.pop();
          path.push({ type: 'waste_to_tab', to: d });
          return true;
        }
        if (!st.tableau[d].length && topW.rank === 'K') {
          st.tableau[d].push(topW);
          st.waste.pop();
          path.push({ type: 'waste_to_tab_empty', to: d });
          return true;
        }
      }
    }
    return false;
  };

  const draw = (st: State) => {
    if (st.stock.length === 0) {
      if (!st.waste.length) return false;
      st.stock = st.waste.slice().reverse().map((c) => ({ ...c, faceUp: false }));
      st.waste = [];
      path.push({ type: 'recycle' });
      return true;
    }
    const n = Math.min(st.drawMode, st.stock.length);
    const take = st.stock.slice(-n).map((c) => ({ ...c, faceUp: true }));
    st.stock = st.stock.slice(0, st.stock.length - n);
    st.waste = st.waste.concat(take);
    path.push({ type: 'draw', n });
    return true;
  };

  const isWin = (st: State) => SUITS.every((s) => st.found[s].length === 13);

  let it = 0;
  let st = deep(initial);
  while (it++ < MAX_ITERS) {
    if (isWin(st)) return { ok: true as const, path };
    const snap = key(st);
    if (seen.has(snap)) {
      if (!draw(st)) break;
      continue;
    }
    seen.add(snap);

    if (moveToFoundation(st)) continue;
    if (moveToTableau(st)) continue;
    if (draw(st)) continue;
    break;
  }
  return { ok: false as const, path: [] as Move[] };
}

export function easeScore(initial: State, solutionPath: Move[]) {
  const total = solutionPath.length;
  const firstN = solutionPath.slice(0, 30);
  const earlyFound = firstN.filter((m) => m.type === 'tab_to_found' || m.type === 'waste_to_found').length;
  const flips = solutionPath.filter((m) => m.type === 'flip').length;
  const recycles = solutionPath.filter((m) => m.type === 'recycle').length;
  const initialAcesVisible = initial.tableau.reduce((acc, col) => {
    const top = col[col.length - 1];
    return acc + (top && top.rank === 'A' ? 1 : 0);
  }, 0);
  return 300 - total + 6 * earlyFound + 2 * flips + 8 * initialAcesVisible - 12 * recycles;
}

export function pickByDifficulty<T extends { score: number }>(candidates: T[], difficulty: 'easy'|'medium'|'hard'|'extreme') {
  candidates.sort((a, b) => a.score - b.score); // low=hard, high=easy
  const pickIndex = (() => {
    if (difficulty === 'easy') return candidates.length - 1;
    if (difficulty === 'medium') return Math.floor(0.8 * (candidates.length - 1));
    if (difficulty === 'hard') return Math.floor(0.3 * (candidates.length - 1));
    return 0; // extreme
  })();
  return candidates[Math.max(0, Math.min(candidates.length - 1, pickIndex))];
}

export function generateDealForDifficulty(drawMode: 1|3, difficulty: 'easy'|'medium'|'hard'|'extreme') {
  const tries = difficulty === 'easy' ? 60 : difficulty === 'medium' ? 45 : difficulty === 'hard' ? 45 : 60;
  const candidates: { deal: State; solution: { ok: true; path: Move[] }; score: number }[] = [];
  for (let i = 0; i < tries; i++) {
    const d = deal(drawMode);
    const solved = trySolve(deep(d));
    if (!solved.ok) continue;
    const score = easeScore(d, solved.path);
    candidates.push({ deal: d, solution: solved as any, score });
  }
  if (!candidates.length) {
    for (let i = 0; i < 50; i++) {
      const d = deal(drawMode);
      const solved = trySolve(deep(d));
      if (solved.ok) return { deal: d, solution: solved as any };
    }
    return null;
  }
  return pickByDifficulty(candidates, difficulty);
}

===== src/games/solitaire/index.ts =====

export { default as Solitaire } from './Solitaire.ui';
